# exampleNet_paramEst.py
# Automatically generated by Netflux on 26-Oct-2022
# 10/26 by JS to mirror exampleNet_paramEst.m

import numpy as np
from scipy import integrate, interpolate, optimize, linalg
import matplotlib.pyplot as plt
import exampleNet
import exampleNet_params

[speciesNames, tau, ymax, y0, w, n, EC50] = exampleNet_params.loadParams()
w = w.astype(np.float64)  # convert to float64

## === Run initial simulation and generate synthetic data ===
# Run multistep simulation
tspan = [0, 10]
w[0] = 1
w[1] = 0
sol1 = integrate.solve_ivp(exampleNet.ODEfunc, tspan, y0, args=(tau, ymax, w, n, EC50,))
w[0] = 1
w[1] = 1
sol2 = integrate.solve_ivp(exampleNet.ODEfunc, tspan, sol1.y[:, -1], args=(tau, ymax, w, n, EC50,))

t = np.hstack((sol1.t, sol2.t + sol1.t[-1]))
y = np.hstack((sol1.y, sol2.y))
plt.plot(t, y.T)  # current 'ax' is getting other lines, so it causes later errors
plt.xlabel('Time')
plt.ylabel('Fractional activity')
plt.legend(speciesNames)
plt.legend('Original model')

# generate synthetic data
tData = t
yData = y + 0.1 * np.random.randn(y.shape[0], y.shape[1])
plt.plot(tData, yData.T, 'o')


# === Run parameter estimation ===

# Run parameter estimation for w[2] and w[3]
def objectiveFunction(paramsEst, tau, ymax, w, n, EC50, tspan, tData, yData):
    w = w.astype(np.float64)  # convert to float64
    w[2], w[3] = paramsEst

    # Run multistep simulation
    w[0] = 1
    w[1] = 0
    sol1 = integrate.solve_ivp(exampleNet.ODEfunc, tspan, y0, args=(tau, ymax, w, n, EC50,))
    w[0] = 1
    w[1] = 1
    sol2 = integrate.solve_ivp(exampleNet.ODEfunc, tspan, sol1.y[:, -1], args=(tau, ymax, w, n, EC50,))
    t = np.hstack((sol1.t, sol2.t + sol1.t[-1]))  # concatentate t's
    y = np.hstack((sol1.y, sol2.y))  # concatenate y's

    yInterp = interpolate.interp1d(t, y[4, :])  # create an interpolation function
    error = yData[4, :] - yInterp(tData)  # compute error at resampled locations
    return error


params0 = [0.5, 0.5]  # initial guess for w[2] and w[3]
result = optimize.least_squares(objectiveFunction, params0, args=(tau, ymax, w, n, EC50, tspan, tData, yData))
paramsEst = result.x

# === Run simulations using estimated parameters

# generate parameter ensemble
# note in this particular example the covariance is huge. If the parameters had
# been more identifiable it would be much smaller.
covariance = result.cost * linalg.inv((np.matmul(result.jac.T, result.jac))) / len(yData)
numIter = 10;
paramEnsemble = np.random.multivariate_normal(paramsEst, covariance, numIter)
paramsStd = np.std(paramEnsemble, axis=0)

# plot parameter estimates
plt.figure()
plt.bar(['w2', 'w3'], paramsEst)
plt.errorbar(['w2', 'w3'], paramsEst, paramsStd)
plt.show()

# run ensemble simulations
plt.figure()
for i in range(numIter - 1):
    w[0] = 1
    w[1] = 0
    w[2] = paramEnsemble[i, 0]
    w[3] = paramEnsemble[i, 1]
    sol1 = integrate.solve_ivp(exampleNet.ODEfunc, tspan, y0,
                               args=(tau, ymax, w, n, EC50,))  # BUG TypeError: 'int' object is not subscriptable
    w[0] = 1
    w[1] = 1
    sol2 = integrate.solve_ivp(exampleNet.ODEfunc, tspan, sol1.y[:, -1], args=(tau, ymax, w, n, EC50,))

    t = np.hstack((sol1.t, sol2.t + sol1.t[-1]))
    y = np.hstack((sol1.y, sol2.y))
    plt.plot(t, y.T)

plt.plot(tData, yData.T, 'o')
plt.xlabel('Time')
plt.ylabel('Fractional activity')
plt.legend(speciesNames)
plt.title('Ensemble predictions')
plt.show()